name: Build & Push Docker Images & Deploy Aliyun

on:
  push:
    branches:
      - tag/*
  release:
    types: [published]

jobs:
  confirm-ecs-install-docker:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
      - name: SSH to ECS and check/install Docker
        env:
          SSH_PRIVATE_KEY: ${{ secrets.ECS_SSH_PRIVATE_KEY }}
          ECS_IP: ${{ secrets.ECS_IP }}
          ECS_USER: ${{ secrets.ECS_USER }}
        run: |
          echo "$SSH_PRIVATE_KEY" > private_key.pem
          chmod 600 private_key.pem
          # 使用SSH检查服务是否存在
          if ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP "systemctl is-active --quiet clash"; then
            echo "服务 clash 正在运行"
          else
            echo "开始安装 clash"
            scp -i private_key.pem .reference/clash.tar.gz $ECS_USER@$ECS_IP:/tmp/clash.tar.gz
            scp -i private_key.pem .reference/config.yaml $ECS_USER@$ECS_IP:/tmp/config.yaml
            ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP << EOF
                cd /tmp
                mkdir /etc/clash
                mv config.yaml /etc/clash/
                tar -zxvf clash.tar.gz
                chmod u+x clash/clash
                mv clash/clash.service /etc/systemd/system/
                mv clash/clash /usr/local/bin/
                mv clash/Country.mmdb /etc/clash/
                rm -fr clash
                systemctl enable clash
                systemctl start clash
                export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890
                echo 'export https_proxy=http://127.0.0.1:7890 http_proxy=http://127.0.0.1:7890 all_proxy=socks5://127.0.0.1:7890' >> ~/.bashrc
                echo "clash 安装完成."
          EOF
          fi
          ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP << EOF
            # 检查 Docker 是否已安装
            if ! command -v docker &> /dev/null; then
                echo "Docker 未安装，正在安装..."
                # 安装 Docker 的命令
                sudo yum update -y
                sudo yum install -y yum-utils device-mapper-persistent-data lvm2
                sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo
                sudo yum install -y docker-ce docker-ce-cli containerd.io
                sudo systemctl start docker
                sudo systemctl enable docker
                echo "Docker 安装完成."
            else
                echo "Docker 已安装，版本为：$(docker --version)"
            fi
          EOF

          # 更新 docker 的 proxy
          ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP << EOF
            # 使用grep检查环境变量是否存在
            ENV_VARIABLE='Environment="HTTP_PROXY=http://127.0.0.1:7890"'
            if grep -q "\$ENV_VARIABLE" /lib/systemd/system/docker.service; then
              sudo sed -i '/\[Service\]/a Environment="HTTP_PROXY=http://127.0.0.1:7890"' /lib/systemd/system/docker.service
              sudo sed -i '/\[Service\]/a Environment="HTTPS_PROXY=http://127.0.0.1:7890"' /lib/systemd/system/docker.service
              systemctl daemon-reload
              systemctl restart docker
              echo "docker 配置 proxy 完成."
            else
              echo "docker 已配置 proxy"
            fi
          EOF

          # 安装 jq
          ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP << EOF
            # 检查 jq 是否安装
            if command -v jq &> /dev/null; then
                echo "jq is installed, version: $(jq --version)"
            else
                echo "jq is not installed. Installing..."
                # 使用 yum 安装 jq
                sudo yum install -y jq
                echo "jq has been installed."
            fi
          EOF

  check-changes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v2
        with:
            fetch-depth: 5

      - name: Get changed files
        id: get_changed_files
        run: |
          # 获取上一个提交的SHA
          PREVIOUS_COMMIT=$(git rev-parse HEAD^)
          
          # 获取变更文件，并筛选出特定目录（例如：src/）
          CHANGED_FILES=$(git diff --name-only $PREVIOUS_COMMIT HEAD -- src/)
          
          # 将变更文件输出为环境变量
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_ENV
          echo "src changed_files=$CHANGED_FILES"

          # 获取变更文件，并筛选出特定目录（例如：./）
          CHANGED_FILES=$(git diff --name-only $PREVIOUS_COMMIT HEAD -- ./)
          
          # 将变更文件输出为环境变量
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_ENV
          echo ". changed_files=$CHANGED_FILES"

      - name: Output changed files
        run: |
          echo "Changed files in 'src/' directory:"
          echo "${{ env.changed_files }}"

  prepare:
    runs-on: ubuntu-latest
    outputs: 
      SERVICES_JSON: ${{ steps.output_json.outputs.SERVICES_JSON }}
    steps:
      - name: services array
        id: output_json
        run: |
          echo '["backend", "frontend"]' > services.json
          echo "SERVICES_JSON=$(cat services.json)" >> $GITHUB_OUTPUT
                  
  build-and-push-docker-hub:
    runs-on: ubuntu-latest
    needs: prepare
    strategy:
      matrix:
        service: ${{ fromJson(needs.prepare.outputs.SERVICES_JSON) }}
    outputs:
      VERSION: ${{ steps.build_step.outputs.VERSION }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
            fetch-depth: 5

      - name: Get changed files
        id: get_changed_files
        run: |
          # 获取上一个提交的SHA
          PREVIOUS_COMMIT=$(git rev-parse HEAD^)
          
          # 获取变更文件，并筛选出特定目录（例如：src/）
          CHANGED_FILES=$(git diff --name-only $PREVIOUS_COMMIT HEAD -- src/)
          
          # 将变更文件输出为环境变量
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_ENV
          echo "src changed_files=$CHANGED_FILES"

          # 获取变更文件，并筛选出特定目录（例如：./）
          CHANGED_FILES=$(git diff --name-only $PREVIOUS_COMMIT HEAD -- ./)
          
          # 将变更文件输出为环境变量
          echo "changed_files=$CHANGED_FILES" >> $GITHUB_ENV
          echo ". changed_files=$CHANGED_FILES"

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2
        with:
          install: true

      - name: Log in to DockerHub
        uses: docker/login-action@v2
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract version from release tag
        if: github.event_name == 'release'
        run: echo "RELEASE_VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_ENV

      - name: Handle push event
        if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/release/')
        run: echo "RELEASE_VERSION=release" >> $GITHUB_ENV

      - name: Build and push release Docker image for ${{ matrix.service }}
        id: build_step
        if: github.event_name == 'release' || (github.event_name == 'push' && startsWith(github.ref, 'refs/heads/release/'))
        run: |
          echo "VERSION=${{ env.RELEASE_VERSION }}" >> $GITHUB_OUTPUT
          docker buildx create --use
          if [[ "${{ matrix.service }}" == "backend" ]]; then \
            DOCKERFILE=backend.dockerfile; \
            IMAGE_NAME=perplexica-backend; \
          else \
            DOCKERFILE=app.dockerfile; \
            IMAGE_NAME=perplexica-frontend; \
          fi
          docker buildx build --platform linux/amd64,linux/arm64 \
            --cache-from=type=registry,ref=${{ vars.DOCKER_USERNAME }}/${IMAGE_NAME}:${{ env.RELEASE_VERSION }} \
            --cache-to=type=inline \
            -f $DOCKERFILE \
            -t ${{ vars.DOCKER_USERNAME }}/${IMAGE_NAME}:${{ env.RELEASE_VERSION }} \
            --push .

  ecs-start-docker-compose:
    needs: [confirm-ecs-install-docker,build-and-push-docker-hub,prepare]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup jq
        uses: vegardit/gha-setup-jq@v1
        
      - name: Upload and execute compose file to ecs
        env:
          SSH_PRIVATE_KEY: ${{ secrets.ECS_SSH_PRIVATE_KEY }}
          ECS_IP: ${{ secrets.ECS_IP }}
          ECS_USER: ${{ secrets.ECS_USER }}
        run: |
          echo "$SSH_PRIVATE_KEY" > private_key.pem
          echo "DOCKER_USERNAME=${{ vars.DOCKER_USERNAME }}" > .tmp.env
          chmod 600 private_key.pem
          ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP << EOF
            # 检查目录是否已存在
            if [ -d "/data" ]; then
              echo "delete data dir"
              rm -fr "/data"
            fi
            echo "mkdir data dir"
            mkdir -p "/data"  
          EOF
          scp -i private_key.pem docker-compose-prod.yaml $ECS_USER@$ECS_IP:/data/docker-compose.yaml
          scp -i private_key.pem .tmp.env $ECS_USER@$ECS_IP:/data/.env
          scp -i private_key.pem xu.config.toml $ECS_USER@$ECS_IP:/data/config.toml
          ssh -o StrictHostKeyChecking=no -i private_key.pem $ECS_USER@$ECS_IP << EOF
            set -e  # 如果任何命令失败，退出脚本
            cd /data || { echo "Failed to change directory to /data"; exit 1; }

            # 创建 services.json 文件
            echo '${{ needs.prepare.outputs.SERVICES_JSON }}' > services.json

            # 检查 services.json 是否成功创建
            if [ ! -f services.json ]; then
                echo "services.json was not created successfully."
                exit 1
            fi
            services=\$(jq -r '.[]' services.json)
            # 使用jq解析并遍历服务数组
            for service in \$services; do
              echo "service -> \$service"
              IMAGE=${{ vars.DOCKER_USERNAME }}/perplexica-\$service:${{ needs.build-and-push-docker-hub.outputs.VERSION }}
              # 使用docker images命令检查镜像是否存在
              if [ "\$(docker images -q \$IMAGE 2> /dev/null)" == "" ]; then
                  continue
              fi
              local_image_id=\$(docker images --no-trunc \$IMAGE -q)
              remote_image_id=\$(docker inspect --format='{{.Id}}' \$IMAGE)
              echo "\$service: local[\$local_image_id]; remote[\$remote_image_id]"
            done
            docker compose down
            docker compose up -d 
          EOF
